# Planning Agent Examples

## Example 1: Add User Profile Avatar Upload

### Input
```json
{
  "ticketId": "PROJ-456",
  "ticketDetails": {
    "summary": "Allow users to upload profile avatars",
    "description": "Users should be able to upload a profile picture. Support JPEG, PNG formats. Max 5MB. Should resize to standard sizes (32x32, 64x64, 256x256)."
  },
  "discoveryResults": {
    "relevantRepos": [
      {"name": "user-service", "relevance": 1.0},
      {"name": "frontend", "relevance": 0.9}
    ]
  },
  "organizationConventions": {
    "branchNaming": "feature/{ticket_id}-{slug}",
    "testFrameworks": {"python": "pytest", "typescript": "jest"}
  }
}
```

### Expected PLAN.md Output

```markdown
# PROJ-456: Allow users to upload profile avatars

## Summary
Implement profile avatar upload functionality allowing users to upload JPEG/PNG images up to 5MB, automatically resizing to standard sizes (32x32, 64x64, 256x256) and storing in S3.

## Scope

### In Scope
- ✅ File upload endpoint accepting JPEG/PNG up to 5MB
- ✅ Image validation (format, size, dimensions)
- ✅ Automatic resizing to 32x32, 64x64, 256x256
- ✅ S3 storage with CDN URL generation
- ✅ Frontend upload component with preview
- ✅ Update user profile to include avatar URL

### Out of Scope
- ❌ Image cropping tool (future enhancement)
- ❌ Animated GIF support
- ❌ Avatar history/versioning

## Architecture

### Components
| Component | Path | Responsibility |
|-----------|------|----------------|
| AvatarService | `user-service/src/services/avatar_service.py` | Handle upload, validation, resizing |
| ImageProcessor | `user-service/src/utils/image_processor.py` | Resize images using Pillow |
| S3Storage | `user-service/src/storage/s3_storage.py` | Upload to S3, generate CDN URLs |
| AvatarUpload | `frontend/src/components/AvatarUpload.tsx` | UI component for file selection |

### Data Flow
```
User -> Frontend (file select) -> API (multipart/form-data)
  -> AvatarService (validate)
  -> ImageProcessor (resize)
  -> S3Storage (upload)
  -> Database (save URLs)
  -> Frontend (display)
```

## Test Plan

### Unit Tests
- [ ] test_avatar_service_validates_file_type: Reject non-JPEG/PNG files
- [ ] test_avatar_service_validates_file_size: Reject files > 5MB
- [ ] test_image_processor_resize_32: Output 32x32 image
- [ ] test_image_processor_resize_64: Output 64x64 image
- [ ] test_image_processor_resize_256: Output 256x256 image
- [ ] test_image_processor_maintains_aspect_ratio: Crop to square
- [ ] test_s3_storage_upload: Upload returns CDN URL

### Integration Tests
- [ ] test_avatar_upload_flow: Upload file, verify stored in S3, user profile updated

### Frontend Tests
- [ ] test_avatar_upload_component_renders: Component mounts correctly
- [ ] test_avatar_upload_preview: Shows preview before upload
- [ ] test_avatar_upload_error_display: Shows error for invalid files

## Implementation Tasks

| # | Task | Dependencies | Est. Hours |
|---|------|--------------|------------|
| 1 | Write unit tests for ImageProcessor | - | 2 |
| 2 | Implement ImageProcessor with Pillow | 1 | 2 |
| 3 | Write unit tests for AvatarService | - | 2 |
| 4 | Implement AvatarService | 2, 3 | 3 |
| 5 | Write unit tests for S3Storage | - | 1 |
| 6 | Implement S3Storage | 5 | 2 |
| 7 | Write integration tests | 4, 6 | 2 |
| 8 | Add upload API endpoint | 4, 6 | 1 |
| 9 | Write frontend component tests | - | 2 |
| 10 | Implement AvatarUpload component | 8, 9 | 3 |
| 11 | Update user profile page | 10 | 1 |

**Total Estimated Hours:** 21

## Security Considerations
- [x] Validate file content matches extension (magic bytes)
- [x] Sanitize filenames before S3 upload
- [x] Require authentication for upload endpoint
- [x] Rate limit uploads (max 10 per hour per user)
- [x] Scan uploaded images for malware (ClamAV integration)

## Rollback Plan
1. Revert frontend changes (users see default avatar)
2. Revert API changes (endpoint returns 404)
3. Existing avatars in S3 remain unchanged

---
*Generated by AI Planning Agent*
```

---

## Example 2: Fix N+1 Query Performance Issue

### Input
```json
{
  "ticketId": "PROJ-789",
  "ticketDetails": {
    "summary": "Fix slow order list page (N+1 query issue)",
    "description": "Order list page takes 15s to load. Profiling shows N+1 query in OrderRepository.get_orders_with_items(). Each order triggers separate query for items."
  },
  "discoveryResults": {
    "relevantRepos": [
      {"name": "order-service", "relevance": 1.0}
    ]
  }
}
```

### Expected PLAN.md Output

```markdown
# PROJ-789: Fix slow order list page (N+1 query issue)

## Summary
Optimize OrderRepository.get_orders_with_items() to use eager loading instead of lazy loading, eliminating N+1 query pattern and reducing page load time from 15s to <1s.

## Scope

### In Scope
- ✅ Add eager loading for order items in get_orders_with_items()
- ✅ Add database index for order_items.order_id
- ✅ Add query performance monitoring

### Out of Scope
- ❌ Pagination (separate ticket)
- ❌ Caching layer (future optimization)
- ❌ Database schema changes

## Architecture

### Components
| Component | Path | Responsibility |
|-----------|------|----------------|
| OrderRepository | `src/repositories/order_repository.py` | Query optimization |
| Database Migration | `migrations/002_add_order_items_index.sql` | Add index |

### Current vs New Query Pattern
**Current (N+1):**
```sql
SELECT * FROM orders WHERE user_id = ?;  -- 1 query
SELECT * FROM order_items WHERE order_id = ?;  -- N queries
```

**New (Eager Load):**
```sql
SELECT o.*, oi.* FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE o.user_id = ?;  -- 1 query
```

## Test Plan

### Unit Tests
- [ ] test_get_orders_with_items_single_query: Verify only 1 database query executed
- [ ] test_get_orders_includes_items: Each order includes its items
- [ ] test_get_orders_empty_items: Orders with no items return empty list
- [ ] test_query_performance: Query executes in <100ms for 100 orders

### Integration Tests
- [ ] test_order_list_api_performance: API response time <500ms for 50 orders

## Implementation Tasks

| # | Task | Dependencies | Est. Hours |
|---|------|--------------|------------|
| 1 | Write performance benchmark test | - | 1 |
| 2 | Write unit tests for eager loading | - | 1 |
| 3 | Implement eager loading in repository | 2 | 2 |
| 4 | Create database migration for index | - | 0.5 |
| 5 | Run migration in staging | 4 | 0.5 |
| 6 | Verify performance improvement | 3, 5 | 1 |

**Total Estimated Hours:** 6

## Security Considerations
- [x] No new security concerns - internal query optimization

## Rollback Plan
1. Revert repository changes (N+1 returns but functional)
2. Index can remain (harmless, benefits other queries)

---
*Generated by AI Planning Agent*
```

---

## Example 3: Multi-Repo Feature - Webhooks Integration

### Input
```json
{
  "ticketId": "PROJ-234",
  "ticketDetails": {
    "summary": "Add webhook notifications for order events",
    "description": "Allow merchants to configure webhook URLs. Send POST requests when order status changes (created, paid, shipped, delivered)."
  },
  "discoveryResults": {
    "relevantRepos": [
      {"name": "merchant-service", "relevance": 0.9},
      {"name": "order-service", "relevance": 1.0},
      {"name": "webhook-service", "relevance": 1.0}
    ],
    "crossRepoDependencies": [
      {"from": "order-service", "to": "webhook-service", "type": "event"}
    ]
  }
}
```

### Expected Output Structure

The plan would include:
- Multiple PRs (one per repository)
- Shared event schema definition
- Event publishing in order-service
- Webhook delivery in webhook-service
- Configuration UI in merchant-service
- Clear deployment order (schema → publisher → consumer → UI)
